//! Assembler binary for the Rusty 16-bit VM.
//!
//! This binary provides functionality to convert assembly language source files
//! into bytecode that can be executed by the VM.
//!
//! # Usage
//!
//! ```
//! cargo run --bin asm -- path/to/assembly_file > output.hex
//! ```
//!
//! # Assembly Format
//!
//! See the `asm` module documentation for the supported assembly syntax.

pub mod asm;

use std::{
    env,
    fs::File,
    io::{self, BufRead, BufReader, Write},
    path::Path,
};

/// Main function for the assembler binary.
///
/// This function:
/// 1. Reads an assembly source file
/// 2. Parses the assembly instructions
/// 3. Converts them to bytecode
/// 4. Outputs the bytecode to stdout
///
/// # Arguments
///
/// * First argument: Path to the assembly source file
///
/// # Returns
///
/// * `Ok(())` - If assembly and bytecode generation was successful
/// * `Err(String)` - Error message if any step failed
fn main() -> Result<(), String> {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        return Err(format!("usage: {} <input>", args[0]));
    }

    let file: File = match File::open(Path::new(&args[1])) {
        Err(e) => {
            return Err(format!("failed to open the file, err - {}", e));
        }
        Ok(f) => f,
    };

    // Process:
    // 1. Read the file line by line
    //
    // 2. For each line break that into multiple parts
    // divided by spaces
    //
    // 3. Each part will be a specific operator or operand
    //
    // 4. Parse them into bytecode (opcodes and arguments)

    let lines: Vec<String> = match BufReader::new(file).lines().collect() {
        Ok(lines) => lines,
        Err(e) => {
            return Err(format!("cannot read the file due to - {}", e));
        }
    };

    // Parse the tokens into bytecode
    let mut outputs: Vec<u8> = Vec::new();

    for l in lines {
        // Skip empty lines or handle comments (lines that start with semicolon)
        if l.trim().is_empty() || l.trim_start().starts_with(';') {
            continue;
        }

        // Split by whitespace to properly handle multiple spaces
        let parts: Vec<&str> = l.split_whitespace().collect();

        // Skip empty parts array (blank lines)
        if parts.is_empty() {
            continue;
        }

        // Parse each token into instruction bytecode
        match asm::parse_parts(parts) {
            Ok(o) => {
                outputs.extend(o);
            }
            Err(e) => {
                return Err(format!("Error parsing line '{}': {}", l, e));
            }
        }
    }

    // Write the generated bytecode to stdout
    let mut out = io::stdout().lock();
    out.write_all(&outputs).map_err(|x| format!("{}", x))?;

    Ok(())
}
