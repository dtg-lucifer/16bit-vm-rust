//! Assembler binary for the Rusty 16-bit VM.

pub mod asm;
pub mod lexer;
pub mod parser;

use std::{
    env,
    fs::File,
    io::{self, BufRead, BufReader, Write},
    path::Path,
};

/// Main function for the assembler binary.
/// Reads an assembly source file, converts to bytecode, outputs to stdout.
fn main() -> Result<(), String> {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        return Err(format!("usage: {} <input>", args[0]));
    }

    let file: File = match File::open(Path::new(&args[1])) {
        Err(e) => {
            return Err(format!("failed to open the file, err - {}", e));
        }
        Ok(f) => f,
    };

    // Process the file line by line and convert to bytecode

    let lines: Vec<String> = match BufReader::new(file).lines().collect() {
        Ok(lines) => lines,
        Err(e) => {
            return Err(format!("cannot read the file due to - {}", e));
        }
    };

    // Parse the tokens into bytecode
    let mut outputs: Vec<u8> = Vec::new();

    for l in lines {
        // Skip empty lines or handle full-line comments (lines that start with semicolon)
        if l.trim().is_empty() || l.trim_start().starts_with(';') {
            continue;
        }

        // Split the line at the first semicolon to handle inline comments
        let code_part = l.split(';').next().unwrap_or("").trim();

        // If after removing comments the line is empty, skip it
        if code_part.is_empty() {
            continue;
        }

        // Split by whitespace to properly handle multiple spaces
        let parts: Vec<&str> = code_part.split_whitespace().collect();

        // Skip empty parts array (blank lines)
        if parts.is_empty() {
            continue;
        }

        // Parse each token into instruction bytecode
        match asm::parse_parts(parts) {
            Ok(o) => {
                outputs.extend(o);
            }
            Err(e) => {
                return Err(format!("Error parsing line '{}': {}", l, e));
            }
        }
    }

    // Write the generated bytecode to stdout
    let mut out = io::stdout().lock();
    out.write_all(&outputs).map_err(|x| format!("{}", x))?;

    Ok(())
}
