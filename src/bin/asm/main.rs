//! Assembler binary for the Rusty 16-bit VM.

pub mod codegen;
pub mod ir;
pub mod lexer;
pub mod parser;

use std::{
    env,
    fs::File,
    io::{self, BufRead, BufReader, Write},
    path::Path,
};

use crate::lexer::Token;

/// Main function for the assembler binary.
/// Reads an assembly source file, converts to bytecode, outputs to stdout.
fn main() -> Result<(), String> {
    let args: Vec<_> = env::args().collect();
    if args.len() != 2 {
        return Err(format!("usage: {} <input>", args[0]));
    }

    let file: File = match File::open(Path::new(&args[1])) {
        Err(e) => {
            return Err(format!("failed to open the file, err - {}", e));
        }
        Ok(f) => f,
    };

    // Process the file line by line and convert to bytecode

    let lines: Vec<String> = match BufReader::new(file).lines().collect() {
        Ok(lines) => lines,
        Err(e) => {
            return Err(format!("cannot read the file due to - {}", e));
        }
    };

    // Parse the tokens into bytecode
    // let mut outputs: Vec<u8> = Vec::new();

    let mut all_tokens: Vec<Token> = Vec::new();

    for l in lines {
        // Skip empty lines or handle full-line comments (lines that start with semicolon)
        if l.trim().is_empty() || l.trim_start().starts_with(';') {
            continue;
        }

        // Split the line at the first semicolon to handle inline comments
        let code_part = l.split(';').next().unwrap_or("").trim();

        // If after removing comments the line is empty, skip it
        if code_part.is_empty() {
            continue;
        }

        // Tokenize the code part into instruction parts
        let tokens = Token::tokenize_line(code_part);
        all_tokens.extend(tokens);
    }

    let ir = parser::parse_tokens(&all_tokens);
    let byte_code =
        codegen::generate_bytecode(&ir).map_err(|e| format!("Error generating bytecode: {}", e))?;

    // Write the generated bytecode to stdout
    let mut out = io::stdout().lock();
    out.write_all(&byte_code).map_err(|x| format!("{}", x))?;

    Ok(())
}
